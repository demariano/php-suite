<!-- Generated by AI -->

# WebSocket Implementation

A comprehensive WebSocket system for real-time communication in the frontend application. Supports both native WebSocket connections for production and Socket.io for local development, with automatic lifecycle management and reconnection capabilities.

## Features

-   ‚úÖ **Dual Protocol Support** - Native WebSocket for production, Socket.io for local development
-   ‚úÖ **Automatic Lifecycle Management** - Auto-connect/disconnect based on authentication status
-   ‚úÖ **Smart Reconnection** - Handles network changes, tab visibility, and page lifecycle
-   ‚úÖ **Type Safety** - Full TypeScript support with `BroadcastMessageDto`
-   ‚úÖ **Connection State Management** - Global state tracking with Zustand (local storage)
-   ‚úÖ **Periodic Health Checks** - Configurable ping messages to keep connection alive
-   ‚úÖ **Authentication Integration** - Token-based authentication with automatic cleanup

## Architecture Overview

### Core Files

1. **`libs/frontend/data-access/src/websocket/socket.ts`**

    - Low-level WebSocket connection management
    - Handles both native WebSocket and Socket.io protocols
    - Connection establishment, state tracking, and cleanup

2. **`libs/frontend/data-access/src/hooks/useWebSocket.ts`**

    - React hook for WebSocket functionality
    - Message sending/receiving with error handling
    - Connection status monitoring

3. **`libs/frontend/data-access/src/hooks/useWebSocketLifecycle.ts`**

    - Advanced lifecycle management
    - Auto-connect/disconnect based on authentication
    - Handles tab visibility, network changes, and periodic pings

4. **`libs/frontend/data-access/src/local-state-management/createWebsocketSlice.ts`**
    - Zustand slice for connection ID storage
    - Persistent connection state management

## Environment Configuration

WebSocket behavior is controlled by environment variables that must be added to your environment configuration:

```typescript
// libs/frontend/data-access/src/config/env.ts
export const ENV_KEYS = [
    // ... other environment variables
    'WEBSOCKET_URL', // Production WebSocket URL (wss://)
    'WEBSOCKET_LOCAL_URL', // Local development URL (http://localhost:3001)
    'PING_INTERVAL', // Ping interval in seconds (default: 300)
    // ... other environment variables
] as const;
```

**‚ö†Ô∏è Important**: Make sure to add `WEBSOCKET_URL` and `WEBSOCKET_LOCAL_URL` to the `ENV_KEYS` array in `libs/frontend/data-access/src/config/env.ts` before using the WebSocket system.

### Environment Variables:

-   **`WEBSOCKET_URL`** - Production WebSocket URL (e.g., `wss://api.example.com/websocket`)
-   **`WEBSOCKET_LOCAL_URL`** - Local development URL (e.g., `http://localhost:3001`)
-   **`LOCALSTACK_STATUS`** - Set to `'ENABLED'` for local development, `'DISABLED'` for production
-   **`PING_INTERVAL`** - Ping interval in seconds (default: 300)

## Usage Patterns

### 1. Basic Setup (Recommended)

Initialize WebSocket lifecycle in your protected route component:

```typescript
// apps/web-app/src/components/global/protected-route/protected-route.tsx
import useWebSocketLifecycle from '@data-access/hooks/useWebSocketLifecycle';

const ProtectedRoute = ({ children }: { children: ReactNode }) => {
    // Initialize WebSocket with full lifecycle management
    useWebSocketLifecycle({
        autoConnect: true, // Connect when user is authenticated
        disconnectOnVisibilityChange: true, // Disconnect when tab is hidden
        reconnectOnVisibilityReturn: true, // Reconnect when tab becomes visible
        disconnectOnNetworkChange: true, // Handle network changes
        sendPeriodicPingMessage: true, // Send periodic ping messages
    });

    return <>{children}</>;
};
```

### 2. Sending Messages

Use the `useWebSocket` hook in any component to send messages:

```typescript
// apps/web-app/src/app/(authenticated-routes)/dashboard/page.tsx
import useWebSocket from '@data-access/hooks/useWebSocket';

const DashboardPage = () => {
    const [message, setMessage] = useState('test message');
    const { sendMessage, isConnected } = useWebSocket();

    const handleSendMessage = () => {
        sendMessage(message); // Sends with default action 'sendMessage'
        // Or with custom action:
        // sendMessage(message, 'customAction');
    };

    return (
        <div>
            <input value={message} onChange={(e) => setMessage(e.target.value)} />
            <button onClick={handleSendMessage} disabled={!isConnected}>
                Send WebSocket Message
            </button>
            <p>WebSocket Connected: {isConnected ? '‚úÖ Yes' : '‚ùå No'}</p>
        </div>
    );
};
```

### 3. Authentication Integration

WebSocket automatically disconnects when user logs out:

```typescript
// libs/frontend/data-access/src/hooks/useAuth.ts
import { disconnectSocket } from '../websocket/socket';

const useAuth = () => {
    const clearUserDetails = () => {
        // Clear authentication tokens
        Cookies.remove(STORAGE_KEY.ACCESS_TOKEN);
        Cookies.remove(STORAGE_KEY.REFRESH_TOKEN);
        Cookies.remove(STORAGE_KEY.ID_TOKEN);

        // Disconnect websocket when user logs out
        disconnectSocket();

        // Reset app state
        resetSessionStore();
        resetLocalStore();
    };

    return { clearUserDetails };
};
```

## Connection Lifecycle

### Automatic Connection Management

```
1. User authenticates ‚Üí WebSocket connects automatically
2. Tab becomes hidden ‚Üí WebSocket disconnects (optional)
3. Tab becomes visible ‚Üí WebSocket reconnects (optional)
4. Network goes offline ‚Üí WebSocket disconnects
5. Network comes online ‚Üí WebSocket reconnects
6. User logs out ‚Üí WebSocket disconnects immediately
7. App unmounts ‚Üí WebSocket disconnects and cleans up
```

### Manual Connection Control

```typescript
import useWebSocketLifecycle from '@data-access/hooks/useWebSocketLifecycle';

const MyComponent = () => {
    const { connect, disconnect, isConnected } = useWebSocketLifecycle({
        autoConnect: false, // Disable automatic connection
    });

    const handleConnect = () => {
        connect(); // Manual connection
    };

    const handleDisconnect = () => {
        disconnect(); // Manual disconnection
    };

    return (
        <div>
            <button onClick={handleConnect} disabled={isConnected}>
                Connect
            </button>
            <button onClick={handleDisconnect} disabled={!isConnected}>
                Disconnect
            </button>
        </div>
    );
};
```

## Message Format

### Outgoing Messages

```typescript
interface OutgoingMessage {
    action: string;           // Message type/action (default: 'sendMessage')
    message: {
        connectionId: string; // Connection ID from server
        data: string;         // Your message content
    };
}

// Example
{
    "action": "sendMessage",
    "message": {
        "connectionId": "abc123",
        "data": "Hello, server!"
    }
}
```

### Incoming Messages

```typescript
// libs/dto/src/lib/websocket/broadcast.message.dto.ts
interface BroadcastMessageDto {
    action?: string;      // Message action/type
    connectionId: string; // Sender's connection ID
    message: any;         // Message content
}

// Example
{
    "action": "sendMessage",
    "connectionId": "abc123",
    "message": "Hello from server!"
}
```

## Advanced Configuration

### Custom Lifecycle Options

```typescript
useWebSocketLifecycle({
    autoConnect: true, // Auto-connect when authenticated (default: true)
    disconnectOnVisibilityChange: false, // Keep connection when tab hidden (default: false)
    reconnectOnVisibilityReturn: false, // Don't auto-reconnect on tab visible (default: false)
    disconnectOnNetworkChange: true, // Handle network changes (default: false)
    sendPeriodicPingMessage: false, // Disable ping messages (default: true)
});
```

### Development Mode

üìù **Note**: During development, you can disable automatic WebSocket connection by setting `autoConnect: false` in the `useWebSocketLifecycle` configuration. This is useful when testing components without needing an active WebSocket connection.

```typescript
// apps/web-app/src/components/global/protected-route/protected-route.tsx
useWebSocketLifecycle({
    autoConnect: false, // Disable automatic connection during development
    // ... other options
});
```

### Custom Message Handling

```typescript
import useWebSocket from '@data-access/hooks/useWebSocket';

const MyComponent = () => {
    const { sendMessage, isConnected } = useWebSocket();

    // The hook automatically handles incoming messages based on action type
    // Custom message handling is done in the useWebSocket hook itself
    // You can extend the handleMessage function for custom actions

    const sendCustomMessage = () => {
        sendMessage('custom data', 'customAction');
    };

    return (
        <button onClick={sendCustomMessage} disabled={!isConnected}>
            Send Custom Message
        </button>
    );
};
```

## State Management

### Connection ID Storage

```typescript
// Access connection ID anywhere in the app
import { useLocalStore } from '@data-access/local-state-management';

const MyComponent = () => {
    const { connectionId, updateWebsocketConnection, clearWebsocketConnection } = useLocalStore();

    // connectionId is automatically set when WebSocket connects
    console.log('Current connection ID:', connectionId);

    return <div>Connection ID: {connectionId || 'Not connected'}</div>;
};
```

### Connection Status Monitoring

```typescript
import useWebSocket from '@data-access/hooks/useWebSocket';

const ConnectionStatus = () => {
    const { isConnected, connectionId } = useWebSocket();

    return (
        <div className={`status ${isConnected ? 'connected' : 'disconnected'}`}>
            <span>Status: {isConnected ? 'Connected' : 'Disconnected'}</span>
            {connectionId && <span>ID: {connectionId}</span>}
        </div>
    );
};
```

## Protocol Differences

### Production (Native WebSocket)

```typescript
// Automatic protocol selection based on LOCALSTACK_STATUS
const wsUrl = new URL(env.WEBSOCKET_URL);
if (token) {
    wsUrl.searchParams.set('token', token); // Token in query string
}
const socket = new WebSocket(wsUrl.toString());

// Event handling
socket.onopen = () => setIsConnected(true);
socket.onmessage = (event) => handleMessage(event.data);
socket.onclose = () => setIsConnected(false);
socket.onerror = (error) => console.error('WebSocket error:', error);
```

### Local Development (Socket.io)

```typescript
// Automatic protocol selection based on LOCALSTACK_STATUS
import { io } from 'socket.io-client';

const socket = io(env.WEBSOCKET_LOCAL_URL, {
    transports: ['websocket'],
    autoConnect: true,
});

// Event handling
socket.on('connect', () => setIsConnected(true));
socket.on('local-server-message', (msg) => handleMessage(msg));
socket.on('disconnect', () => setIsConnected(false));
socket.on('error', (error) => console.error('Socket.io error:', error));
```

## Error Handling

### Connection Errors

```typescript
// Automatic error handling in useWebSocket hook
const sendMessage = (data: string, action = 'sendMessage') => {
    try {
        const socket = getSocket();

        if (!socket || !isSocketReady()) {
            throw new Error('WebSocket is not connected');
        }

        // Send message...
    } catch (error) {
        console.error('Failed to send message:', error);

        // Show user-friendly error notification
        setFlashNotification({
            title: 'Failed to send message',
            message: error instanceof Error ? error.message : 'Unknown error',
            alertType: 'error',
        });
    }
};
```

### Reconnection Logic

```typescript
// Automatic reconnection on network/visibility changes
useEffect(() => {
    const handleOnline = () => {
        if (isUserAuthenticated) {
            initSocket(); // Automatic reconnection
        }
    };

    const handleOffline = () => {
        disconnectSocket(); // Clean disconnection
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
        window.removeEventListener('online', handleOnline);
        window.removeEventListener('offline', handleOffline);
    };
}, [isUserAuthenticated, initSocket]);
```

## Best Practices

### 1. Use Lifecycle Hook in Protected Routes

```typescript
// ‚úÖ Good: Initialize in protected route for automatic management
const ProtectedRoute = ({ children }) => {
    useWebSocketLifecycle({ autoConnect: true });
    return <>{children}</>;
};

// ‚ùå Bad: Initialize in every component
const MyComponent = () => {
    useWebSocketLifecycle({ autoConnect: true }); // Redundant
    return <div>Content</div>;
};
```

### 2. Check Connection Before Sending

```typescript
// ‚úÖ Good: Check connection status
const { sendMessage, isConnected } = useWebSocket();

const handleSend = () => {
    if (!isConnected) {
        console.warn('WebSocket not connected');
        return;
    }
    sendMessage('Hello');
};

// ‚ùå Bad: Send without checking
const handleSend = () => {
    sendMessage('Hello'); // May fail if not connected
};
```

### 3. Handle Authentication Changes

```typescript
// ‚úÖ Good: WebSocket automatically handles auth changes
useWebSocketLifecycle({
    autoConnect: true, // Connects when authenticated
});

// When user logs out, useAuth hook calls disconnectSocket()
// When user logs in, lifecycle hook auto-connects

// ‚ùå Bad: Manual connection management without auth checks
const connect = () => {
    connectSocket(); // Doesn't check if user is authenticated
};
```

### 4. Use Environment-Specific Configuration

```typescript
// ‚úÖ Good: Let the system handle protocol selection
useWebSocketLifecycle({ autoConnect: true });

// ‚ùå Bad: Hardcode protocol or URL
const socket = new WebSocket('wss://hardcoded-url.com');
```

## Debugging

### Connection Status

```typescript
// Check connection status
import { isSocketReady, getSocket } from '@data-access/websocket/socket';

console.log('Socket ready:', isSocketReady());
console.log('Socket instance:', getSocket());
```

### Environment Variables

```typescript
// Check WebSocket configuration
import { useEnv } from '@data-access/hooks/useEnv';

const { env } = useEnv();
console.log('WebSocket URL:', env.WEBSOCKET_URL);
console.log('Local WebSocket URL:', env.WEBSOCKET_LOCAL_URL);
console.log('Localstack Status:', env.LOCALSTACK_STATUS);
console.log('Ping Interval:', env.PING_INTERVAL);
```

### Message Monitoring

```typescript
// Monitor messages in development
const { sendMessage } = useWebSocket();

const handleSend = (message: string) => {
    console.log('Sending message:', message);
    sendMessage(message);
};

// Messages are automatically logged in the useWebSocket hook
```

## Integration with Backend

The WebSocket system integrates with the following backend services:

-   **Connect Service**: Handles initial connection establishment
-   **Broadcast Message Service**: Processes and distributes messages
-   **Client Message Processor Service**: Handles incoming client messages

Backend connection flow:

1. Client connects with authentication token
2. Server validates token and establishes connection
3. Server sends connection confirmation with `connectionId`
4. Client stores `connectionId` for future message sending
5. Messages are routed through AWS API Gateway WebSocket API

## Performance Considerations

### Memory Management

-   WebSocket connections are automatically cleaned up on component unmount
-   Connection state is managed globally to prevent multiple instances
-   Periodic ping messages prevent connection timeouts (configurable interval)

### Network Efficiency

-   Automatic reconnection prevents unnecessary connection attempts
-   Tab visibility detection reduces bandwidth usage when app is hidden
-   Connection pooling through global state management

### Error Recovery

-   Exponential backoff for reconnection attempts (built into browser WebSocket)
-   Graceful degradation when WebSocket is unavailable
-   User feedback through flash notifications for connection issues
