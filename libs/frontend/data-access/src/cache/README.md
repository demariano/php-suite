<!-- Generated by AI -->

# Secrets Cache

A global, type-safe caching system for managing secrets in the frontend application. Provides automatic expiration, memory management, and multiple access patterns.

## Features

-   ‚úÖ **Global Accessibility** - Use secrets anywhere in your app
-   ‚úÖ **Type Safety** - Full TypeScript support with `SecretKeyName` type
-   ‚úÖ **TTL Expiration** - Automatic cleanup after 2 hours
-   ‚úÖ **Memory Management** - Efficient cache with automatic expired entry removal
-   ‚úÖ **Multiple Access Patterns** - Direct cache access or React hook integration

## Important: Secrets Must Be Fetched First

‚ö†Ô∏è **The cache starts empty!** Secrets must be fetched using the `useSecrets` hook before they become available in the cache.

üìù **Note**: All secret keys must first be defined in `libs/frontend/data-access/src/config/constants.ts` in the `SECRET_KEYS` object before they can be used.

### Two Ways to Fetch Secrets:

1. **On Initial App Load** (Recommended for commonly used secrets):

    Configure secrets in constants, then they're automatically loaded:

    ```typescript
    // libs/frontend/data-access/src/config/constants.ts
    export const INITIAL_SECRETS: SecretKeyName[] = [
        'API_KEY',
        'STRIPE_PUBLIC_KEY',
        // Add secrets that should be loaded on app start
    ];
    ```

    ```typescript
    // apps/web-app/src/components/global/client-provider/client-provider.tsx
    import { INITIAL_SECRETS } from '@data-access/config/constants';

    export function ClientProvider({ children }: { children: React.ReactNode }) {
        // Automatically fetch initial secrets configured in constants
        useSecrets(INITIAL_SECRETS);

        return <ReactQueryProvider>{children}</ReactQueryProvider>;
    }
    ```

2. **On Demand** (For secrets used in specific features):

    ```typescript
    // In any React component
    const { getSecret } = useSecrets();

    const handleFeature = async () => {
        const secret = await getSecret('FEATURE_SPECIFIC_SECRET');
        // This fetches from API and caches it for future use
    };
    ```

### Cache Lifecycle:

```
1. App starts ‚Üí Cache is empty
2. useSecrets fetches ‚Üí Secret stored in cache (2hr TTL)
3. getCachedSecret() ‚Üí Returns cached value (fast, synchronous)
4. After 2 hours ‚Üí Secret expires and is auto-removed
5. Page refresh ‚Üí Cache is cleared, starts empty again (step 1)
```

## Usage

### Define Secret Keys First

‚ö†Ô∏è **Important**: Before using any secret, it must be defined in the constants file.

```typescript
// libs/frontend/data-access/src/config/constants.ts
export const SECRET_KEYS = {
    TEST: 'TEST',
    API_KEY: 'api_key_secret_name',
    STRIPE_PUBLIC_KEY: 'stripe_public_key',
    // Add new secrets here
} as const;
```

Once defined, you can use the secret key throughout your app with full TypeScript support.

### Direct Cache Access (Anywhere in App)

‚ö†Ô∏è **Note**: These functions only return values that have already been fetched and cached by `useSecrets`.

```typescript
import { SecretsCache, getCachedSecret } from '@data-access/cache';

// Quick access (returns null if not previously fetched)
const apiKey = getCachedSecret('API_KEY');
if (apiKey) {
    console.log('API key is available:', apiKey);
} else {
    console.log('API key not cached - need to fetch first using useSecrets');
}

// Full cache control
const isAvailable = SecretsCache.has('DATABASE_URL');
const secret = SecretsCache.get('DATABASE_URL');

// Cache management
SecretsCache.delete('API_KEY'); // Remove specific secret
SecretsCache.clear(); // Clear all secrets
const keys = SecretsCache.getAllKeys(); // Get all valid (non-expired) keys
```

### In Utility Functions

```typescript
// utils/apiClient.ts
import { getCachedSecret } from '@data-access/cache';

export async function makeAuthenticatedRequest(url: string) {
    const apiKey = getCachedSecret('API_KEY');
    if (!apiKey) {
        throw new Error('API key not available - ensure it was fetched in ClientProvider or via useSecrets first');
    }

    return fetch(url, {
        headers: {
            Authorization: `Bearer ${apiKey}`,
            'Content-Type': 'application/json',
        },
    });
}

// Alternative: Check if key is available before making requests
export function isApiConfigured(): boolean {
    return getCachedSecret('API_KEY') !== null;
}
```

### In Service Classes

```typescript
// services/PaymentService.ts
import { SecretsCache } from '@data-access/cache';

class PaymentService {
    async processPayment(amount: number) {
        const stripeKey = SecretsCache.get('STRIPE_SECRET_KEY');
        if (!stripeKey) {
            throw new Error('Stripe key not configured');
        }

        // Initialize Stripe with secret key
        const stripe = new Stripe(stripeKey);
        // Process payment...
    }

    isConfigured(): boolean {
        return SecretsCache.has('STRIPE_SECRET_KEY');
    }
}
```

### With React Hook Integration

```typescript
// components/Dashboard.tsx
import { useSecrets } from '@data-access/hooks/useSecrets';

function Dashboard() {
    const { getSecret, isFetching, error } = useSecrets();

    const handleApiCall = async () => {
        // getSecret automatically checks cache first, then fetches if needed
        // No need to call getCachedSecret separately - it's built into getSecret
        const apiKey = await getSecret('API_KEY');

        if (apiKey) {
            // Make API call with the key
            await makeAuthenticatedRequest('/api/data');
        }
    };

    return (
        <div>
            <button onClick={handleApiCall} disabled={isFetching}>
                {isFetching ? 'Loading...' : 'Make API Call'}
            </button>
            {error && <p>Error: {error}</p>}
        </div>
    );
}
```

### Configuration Management

```typescript
// config/appConfig.ts
import { getCachedSecret, SecretsCache } from '@data-access/cache';

export class AppConfig {
    static getApiConfig() {
        return {
            baseUrl: getCachedSecret('API_BASE_URL'),
            apiKey: getCachedSecret('API_KEY'),
            timeout: 30000,
        };
    }

    static getPaymentConfig() {
        return {
            stripeKey: getCachedSecret('STRIPE_PUBLIC_KEY'),
            merchantId: getCachedSecret('MERCHANT_ID'),
        };
    }

    static isFullyConfigured(): boolean {
        const requiredSecrets = ['API_KEY', 'API_BASE_URL', 'STRIPE_PUBLIC_KEY'];
        return requiredSecrets.every((key) => SecretsCache.has(key as any));
    }

    static getMissingSecrets(): string[] {
        const requiredSecrets = ['API_KEY', 'API_BASE_URL', 'STRIPE_PUBLIC_KEY'];
        return requiredSecrets.filter((key) => !SecretsCache.has(key as any));
    }
}
```

## API Reference

### `SecretsCache` Class

Static methods for full cache control:

-   `SecretsCache.get(key)` - Get secret value (null if expired/missing)
-   `SecretsCache.set(key, value)` - Store secret with 2-hour TTL
-   `SecretsCache.has(key)` - Check if secret exists and is valid
-   `SecretsCache.delete(key)` - Remove specific secret
-   `SecretsCache.clear()` - Remove all secrets
-   `SecretsCache.getAllKeys()` - Get array of valid secret keys

### `getCachedSecret(key)` Function

Convenience function for quick access:

```typescript
const secret = getCachedSecret('API_KEY'); // string | null
```

## Cache Behavior

### TTL (Time To Live)

-   **Duration**: 2 hours (7,200,000 ms)
-   **Auto-cleanup**: Expired entries are automatically removed on access
-   **Memory efficient**: No background timers, cleanup happens on-demand
-   **Page refresh**: Cache is completely cleared and starts empty

### Storage Structure

```typescript
interface SecretCacheEntry {
    value: string; // The actual secret value
    timestamp: number; // When it was cached (Date.now())
    ttl: number; // Time to live in milliseconds
}
```

## Best Practices

### 1. Pre-load Common Secrets

Configure commonly used secrets in `INITIAL_SECRETS` to avoid loading delays:

```typescript
// ‚úÖ Good: Configure in constants
// libs/frontend/data-access/src/config/constants.ts
export const INITIAL_SECRETS: SecretKeyName[] = ['API_KEY', 'STRIPE_PUBLIC_KEY'];

// ‚ùå Bad: Load secrets on-demand for common operations
const apiKey = await getSecret('API_KEY'); // Causes loading delay every time
```

### 2. Check Availability Before Use

Always check if secrets are available in utility functions:

```typescript
// ‚úÖ Good: Defensive programming
const apiKey = getCachedSecret('API_KEY');
if (!apiKey) {
    throw new Error('API not configured');
}

// ‚ùå Bad: Assume secrets are always available
const apiKey = getCachedSecret('API_KEY')!; // Could be null!
```

### 3. Use Hook for React Components

Use `useSecrets` in React components for proper loading states:

```typescript
// ‚úÖ Good: Proper loading states
const { getSecret, isFetching } = useSecrets();

// ‚ùå Bad: No loading feedback
const secret = getCachedSecret('SECRET'); // User sees nothing while loading
```

## Integration with Hooks

This cache works seamlessly with the `useSecrets` React hook:

-   Hook handles fetching and stores results in this cache
-   Direct cache access provides immediate (synchronous) results
-   Hook provides loading states and error handling for UX

See `@data-access/hooks/useSecrets` for React-specific usage patterns.

## Server-Side Caching

üìù **Note**: The API route (`/api/secrets`) implements server-side caching with a 24-hour TTL to minimize AWS Secrets Manager API calls. This means:

-   Secrets are cached on the server for 24 hours after first fetch from AWS Secrets Manager
-   Subsequent requests within 24 hours return cached values without hitting AWS Secrets Manager
-   This reduces AWS Secrets Manager API costs and improves response times
-   Server cache is independent of the frontend cache (2-hour TTL)

The server-side cache ensures efficient secret retrieval while the frontend cache provides immediate access for already-fetched secrets.
